package xmlutil

import (
	"bytes"
	"regexp"
)

// CompactEmptyElements converts empty XML elements to self-closing tags.
// This converts <tag></tag> to <tag /> which is the format IDML uses.
//
// Example:
//
//	Input:  <KeyValuePair Key="test" Value="1"></KeyValuePair>
//	Output: <KeyValuePair Key="test" Value="1" />
//
// This function is essential for maintaining byte-for-byte compatibility
// with IDML files generated by Adobe InDesign, which uses self-closing tags
// for empty elements.
func CompactEmptyElements(xml []byte) []byte {
	// Note: Go's regexp doesn't support backreferences, so we can't use a simple
	// pattern like <([^>]+)></\1>. Instead, we match the general pattern and
	// then verify the tag names match.
	//
	// Pattern matches: <tagname attributes></...>
	// where there might be no content between tags
	pattern := regexp.MustCompile(`<([^>\s]+)([^>]*)></([^>\s]+)>`)

	// Replace with self-closing format if opening and closing tags match
	result := pattern.ReplaceAllFunc(xml, func(match []byte) []byte {
		// Extract tag names and attributes
		submatches := pattern.FindSubmatch(match)
		if len(submatches) != 4 {
			return match // shouldn't happen, but be safe
		}

		openTag := submatches[1]
		attrs := submatches[2]
		closeTag := submatches[3]

		// Only convert to self-closing if tags match
		if !bytes.Equal(openTag, closeTag) {
			return match
		}

		// Build self-closing tag
		// If attrs is empty or ends with space, no extra space needed
		// If attrs doesn't end with space, add one before />
		if len(attrs) == 0 || attrs[len(attrs)-1] == ' ' {
			result := append([]byte("<"), openTag...)
			result = append(result, attrs...)
			result = append(result, []byte("/>")...)
			return result
		}

		result := append([]byte("<"), openTag...)
		result = append(result, attrs...)
		result = append(result, []byte(" />")...)
		return result
	})

	return result
}
